# HDLBit与面试题笔记

## assign赋值

wire连接了源(source)与目的地(sink),通常源只有一个,但目的可以有多个.在verilog中`assign`赋值也可以称为连续赋值(continuous assignment).`assign left_side = right_side;`,the value of the signal on the right side is driven onto the wire on the left side.

在使用`assign`时有可能会声明一个隐藏的net类型的信号(implicit nets),implicit net也会因为在模块端口处声明了未定义的信号而产生.

```verilog
    wire [2:0] a, c;
    assign a = 3'b101;
    assign b = a;   // implicit net, b = 1'b1
    assign c = b;   // c = 3'b001
    my_module i1(d,e); // 如果d,e没有定义的话,则它们都是1bit宽的信号.
```

如果想要禁止隐藏net信号的声明,可以使用`` `define_nettype none``

```verilog
assign {out[7:0], out[15:8]} = in;		// in 16bit, out 24bit;
assign out[15:0] = {in[7:0], in[15:8]};
assign out = {in[7:0], in[15:8]};       // 这种情况下out[23:16]会被赋值0;
```

在使用位拼接符一定要标明各个部分的位宽,特别是对于常量.

## verilog中的向量

vectors:将多个相关的信号组合(group)在一起,使用同一个名字来方便操作,也就是说向量都是由单独的信号构成的,可以拆分成独立的信号操作.如下例所示

```verilog
    wire [7:0] vector_bit; 
    reg  [8:0] vector_byte[7:0];
```

vector可以是wire类型,也可以是reg类型.需要注意的是`vector_bit`可以看成==8个1bit==的信号组合在一起,而`vector_byte`应该看成==9个8bit==的信号组合在一起.

`vector_bit`也称为packed arrays,总共有8个1bit信号,vector_bit[0]代表一个1bit的信号.

`vector_byte`也称为unpacked arrays,可以看成有8个存储单元,每个存储单元可以存储9bit的数据.

需要注意的是: 常量9'b00和位拼接符{}所代表的信号都是packed type ,不能赋值给`vector_byte`这种unpacked type.进一步讲,`reg [15:0] unpacked_type[7:0][2:0]`相当于创建了一个存储空间,这个存储空间有8*3个存储单元,每个存储单元可以存储16bit的数据.对于unpacked type类型的变量赋初值只能使用for循环.

## 按位或与逻辑或

verilog中`按位或|`,`按位与&`,`按位取反~`,`按位异或^~`.既可以当单目操作符也可以当双目操作符.

1. 单目操作符
   |a : 如果信号a为向量,则是对a中的各个bit进行进行逻辑或处理,最后得出来的是1个1bit的信号.

2. 双目操作符
   a | b: 当a与b都为向量时,则a,b相应的bit位进行逻辑或处理,最后得到的结果是a,b中最长的位宽.

verilog中有三种逻辑运算符:`逻辑与:&&`, `逻辑或||`, `逻辑非!`.其中逻辑与和逻辑或都是双目运算符.逻辑非为单目运算符.逻辑运算符最后得出来的结果都是1bit的信号,只有真(1),假(0)两种结果.

### 区分== ===

=== | 0 | 1 | x | z |
---------|--------|------|---|---|
 0 | 1 | 0 | 0 | 0 |
 1 | 0 | 1 | 0 | 0 |
 x | 0 | 0 | 1 | 0 |
 z | 0 | 0 | 0 | 1 |

== | 0 | 1 | x | z |
---------|--------|------|---|---|
 0 | 1 | 0 | x | x |
 1 | 0 | 1 | x | x |
 x | x | x | x | x |
 z | x | x | x | x |

!== | 0 | 1 | x | z |
---------|--------|------|---|---|
 0 | 0 | 1 | 1 | 1 |
 1 | 1 | 0 | 1 | 1 |
 x | 1 | 1 | 0 | 1 |
 z | 1 | 1 | 1 | 0 |

!= | 0 | 1 | x | z |
---------|--------|------|---|---|
 0 | 0 | 1 | x | x |
 1 | 1 | 0 | x | x |
 x | x | x | x | x |
 z | x | x | x | x |

`===`和`!==`对操作数进行比较时对某些位的不定值x和高阻值z也进行比较,两个操作数必须完全一致,其结果才为1,否则为0.这两个运算符常用于case表达式的判别.

